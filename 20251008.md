## 1512.好数对

题目：

给你一个整数数组 `nums` 。

如果一组数字 `(i,j)` 满足 `nums[i]` == `nums[j]` 且 `i` < `j` ，就可以认为这是一组 **好数对** 。

返回好数对的数目。

我的解答：

```c
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        vector<int> ::iterator it = nums.begin();
        vector<int> ::iterator it1 = nums.begin();
        int number=0;
        for(;it!=nums.end();it++){
           for(it1=it+1;it1!=nums.end();it1++){
            if(*it1==*it) number++;
           }
        }
        return number;
    }
};
```

- 时间复杂度：*O*(*n*2)。
- 空间复杂度：*O*(1)。

### 组合计数

思路与算法

用哈希表统计每个数在序列中出现的次数，假设数字 $k $在序列中出现的次数为$ v$，那么满足题目中所说的 $nums[i]=nums[j]=k(i<j) $的$(i,j) $的数量就是  $\frac{v(v−1)}{2}$ ，即 k 这个数值对答案的贡献是 $\frac{v(v−1)}{2}$ 。我们只需要把所有数值的贡献相加，即可得到答案。

```c
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        unordered_map <int, int> m;
        for (int num: nums) {
            ++m[num];
        }
        int ans = 0;
        for (const auto &[k, v]: m) {
            ans += v * (v - 1) / 2;
        }
        return ans;
    }
};
```
复杂度分析

* 时间复杂度：O(n)。
* 空间复杂度：O(n)，即哈希表使用到的辅助空间的空间代价。

### 细节分析

#### 1.范围for循环 (Range-based for loop)

```cpp
for (元素类型 变量名 : 容器) {
    // 循环体
}
```

- **`nums`**: 是一个 `vector<int>` 容器
- **`int num`**: 每次循环时，从 `nums` 中取出一个元素赋值给 `num`

**等价于传统for循环**

```cpp
// 范围for循环
for (int num : nums) {
    ++m[num];
}

// 等价的传统for循环
for (int i = 0; i < nums.size(); i++) {
    int num = nums[i];
    ++m[num];
}
```

#### 2.结构化绑定 (Structured Bindings)

```cpp
for (const auto &[key, value] : map) {
    // 循环体
}
```

- **`const auto &[k, v]`**:
  - `auto`: 自动类型推导
  - `const &`: 常量引用，避免复制，保证不修改原数据
  - `[k, v]`: 结构化绑定，自动解包键值对

**等价于传统写法**

```cpp
// 结构化绑定
for (const auto &[k, v] : m) {
    ans += v * (v - 1) / 2;
}

// 等价的传统写法
for (const auto &pair : m) {
    int k = pair.first;    // 键
    int v = pair.second;   // 值
    ans += v * (v - 1) / 2;
}

// 或者使用迭代器
for (auto it = m.begin(); it != m.end(); it++) {
    int k = it->first;     // 键
    int v = it->second;    // 值
    ans += v * (v - 1) / 2;
}
```

### 时空复杂度

### 排序算法

[算法复杂度一览表 - 算法导航](https://algo.codefather.cn/complexity)

[算法中七种常见的时间复杂度_多项式时间复杂度-CSDN博客](https://blog.csdn.net/u013832707/article/details/108647898)

[全面总结：常见数据结构时间复杂度比较表_数据结构时间复杂度汇总-CSDN博客](https://blog.csdn.net/weidl001/article/details/144222476)

### 另一道哈希

https://leetcode-cn.com/problems/two-sum/ （放到202501009了）

## 1534.统计好三元组

### 绝对值函数 abs()

### 枚举优化

思路与算法

我们考虑 $O(n^2)$ 枚举满足 $|arr[i] - arr[k]| \leq b$ 的二元组 $(i, k)$，统计这个二元组下有多少 $j$ 满足条件。 
由题目已知 $j$ 的限制条件为 $|arr[i] - arr[j]| \leq a$ 且 $|arr[j] - arr[k]| \leq c$，我们可以拆开绝对值，得到符合条件的 $arr[j]$ 一定是  
$$
[arr[i] - a, arr[i] + a] \quad\text{和}\quad [arr[k] - c, arr[k] + c]
$$
两个区间的交集，我们记为 $[l, r]$。  

因此，在枚举 $(i, k)$ 这个二元组的时候，我们只需要快速统计出满足 $j < i$ 且 $arr[j]$ 的值域范围在 $[l, r]$ 的 $j$ 的个数即可。

很容易想到维护一个 $arr[j]$ 频次数组的前缀和 $sum$，对于一个二元组 $(i, k)$，我们可以 $O(1)$ 得到答案为  
$$
sum[r] - sum[l - 1]
$$

考虑怎么维护保证当前频次数组存的数的下标符合 $j < i$ 的限制，我们只要从小到大枚举 $i$，每次 $i$ 移动指针加一的时候，将 $arr[i]$ 的值更新到 $sum$ 数组中即可，这样能保证枚举到 $i$ 时 $sum$ 数组里存的值的下标满足限制。

> 「将 $arr[i]$ 的值更新到 $sum$ 数组中」这个操作在本方法中是暴力更新，因为数组的值域上限很小，有能力的读者可以考虑怎么进一步优化这一部分的复杂度，可以从离散化或者树状数组的角度考虑，这里不再赘述。

```c
class Solution {
public:
    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {
        int ans = 0, n = arr.size();
        vector<int> sum(1001, 0);
        for (int j = 0; j < n; ++j) {
            for (int k = j + 1; k < n; ++k) {
                if (abs(arr[j] - arr[k]) <= b) {
                    int lj = arr[j] - a, rj = arr[j] + a;
                    int lk = arr[k] - c, rk = arr[k] + c;
                    int l = max(0, max(lj, lk)), r = min(1000, min(rj, rk));
                    if (l <= r) {
                        if (l == 0) {
                            ans += sum[r];
                        }
                        else {						
                            ans += sum[r] - sum[l - 1];
                        }
                    }
                }
            }
            for (int k = arr[j]; k <= 1000; ++k) {
                ++sum[k];
            }
        }
        return ans;
    }
};
```

复杂度分析

- 时间复杂度：$O(n^2 + nS)$，其中 $n$ 是数组 `arr` 的长度，$S$ 为数组的值域上限，这里为 $1000$。  
- 空间复杂度：$O(S)$。我们需要 $O(S)$ 的空间维护 `arr[i]` 频次数组的前缀和。

#### 理解

```c
for (int j = 0; j < n; ++j) {          // 当前 j
    for (int k = j + 1; k < n; ++k) {    // 固定 j 后枚举 k
        ...                              // 这里只处理 i < j 的 i
    }
    // 把 arr[j] 记入历史，供后面的 j 使用
    for (int v = arr[j]; v <= 1000; ++v) ++sum[v];
}
```

---

✅ 先给结论

> **必须先查询、后更新**，否则就会把 **当前 j 自己** 以及 **后面的 k** 也算成“历史 i”，破坏 **i < j** 的限制。  
> 第一次 j=0 时 `sum` 里确实是 0，**这是对的**，因为此时根本没有 **i < 0** 的元素。

---

✅ 把循环拆成时间线来看

假设 n=4，数组下标 0 1 2 3。

| 轮次 | 当前 j | 查询前 sum 里是谁 | 查询完后才把谁加进去 |
| ---- | ------ | ----------------- | -------------------- |
| 1    | j=0    | 空（sum 全 0）    | 把 arr[0] 写进去     |
| 2    | j=1    | 只有 arr[0]       | 把 arr[1] 写进去     |
| 3    | j=2    | arr[0], arr[1]    | 把 arr[2] 写进去     |
| 4    | j=3    | arr[0]…arr[2]     | 把 arr[3] 写进去     |

- 每次查询时，`sum` 里**恰好**保存的是 **下标 0…j-1** 的值。  
- 更新操作放在查询之后，因此 **当前 j 不会泄露到本次查询中**，更不会把 k 算进来。

---

✅ 为什么“第一次是 0”没问题

- j=0 时，**i 必须 < 0**，这样的 i 根本不存在，所以合法三元组数只能是 0。  
- `sum` 全 0 正好给出 0 个满足条件的 i，**结果正确**。

---

✅ 完整性如何保证

- 每一个 j 都会 **一次性地把 arr[j] 追加到 sum 里**，且**只追加一次**。  
- 后面的 j’ > j 在它们的查询阶段就能看到 **之前所有 j 的贡献**，所以 **不会漏掉任何合法的 i**。

---

✅ 一句话总结

> **查询时 sum 里只有“过去”（i < j）的元素；更新时把“现在”（j）变成“历史”供未来使用。**  
> 这个顺序正是为了**物理上强制执行 i < j**，否则算法就错了。

#### 前缀和

前缀和（Prefix Sum）是一种**预处理技巧**，用来**快速计算数组某一段的和**。

✅ 举个最简单的例子：

有一个数组：

```cpp
int a[] = {3, 1, 4, 1, 5};
```

我们想多次查询：**第 i 到第 j 个数的和**。

普通做法：

每次查询都遍历一遍，时间复杂度是 **O(n)**。

前缀和优化：

我们先预处理一个前缀和数组 `sum`，其中：

```cpp
sum[0] = a[0]
sum[1] = a[0] + a[1]
sum[2] = a[0] + a[1] + a[2]
...
```

也就是：

```cpp
sum[i] = a[0] + a[1] + ... + a[i]
```

那么：

> **a[i] 到 a[j] 的和 = sum[j] - sum[i - 1]**

✅ 查询时间变成：**O(1)**

---

✅ 回到你这题里的前缀和

在你给的代码里，`sum` 不是普通的“前缀和”，而是：

> **值的出现次数的前缀和**

举个例子：

假设我们处理过的 `arr` 值有：

```cpp
arr = [3, 5, 3, 7]
```

那么我们用一个数组 `cnt` 来记录每个值出现了几次：

```cpp
cnt[3] = 2
cnt[5] = 1
cnt[7] = 1
```

再构造一个前缀和数组 `sum`，其中：

==sum[v] = 值 ≤ v 的数的总个数==

比如：

```cpp
sum[3] = 2
sum[5] = 3
sum[7] = 4
```

这样我们就可以**O(1)** 查询：

> 值在区间 `[l, r]` 内出现了几次 = `sum[r] - sum[l - 1]`

---

✅ 总结一句话：

> 前缀和就是一种**预处理技巧**，让你**从 O(n) 查询变成 O(1)**，不管是求和、求个数、求出现次数，都能用。
