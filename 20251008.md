## 1512.好数对

题目：

给你一个整数数组 `nums` 。

如果一组数字 `(i,j)` 满足 `nums[i]` == `nums[j]` 且 `i` < `j` ，就可以认为这是一组 **好数对** 。

返回好数对的数目。

我的解答：

```c
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        vector<int> ::iterator it = nums.begin();
        vector<int> ::iterator it1 = nums.begin();
        int number=0;
        for(;it!=nums.end();it++){
           for(it1=it+1;it1!=nums.end();it1++){
            if(*it1==*it) number++;
           }
        }
        return number;
    }
};
```

- 时间复杂度：*O*(*n*2)。
- 空间复杂度：*O*(1)。

### 组合计数

思路与算法

用哈希表统计每个数在序列中出现的次数，假设数字 $k $在序列中出现的次数为$ v$，那么满足题目中所说的 $nums[i]=nums[j]=k(i<j) $的$(i,j) $的数量就是  $\frac{v(v−1)}{2}$ ，即 k 这个数值对答案的贡献是 $\frac{v(v−1)}{2}$ 。我们只需要把所有数值的贡献相加，即可得到答案。

```c
class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        unordered_map <int, int> m;
        for (int num: nums) {
            ++m[num];
        }
        int ans = 0;
        for (const auto &[k, v]: m) {
            ans += v * (v - 1) / 2;
        }
        return ans;
    }
};
```
复杂度分析

* 时间复杂度：O(n)。
* 空间复杂度：O(n)，即哈希表使用到的辅助空间的空间代价。

### 细节分析

#### 1.范围for循环 (Range-based for loop)

```cpp
for (元素类型 变量名 : 容器) {
    // 循环体
}
```

- **`nums`**: 是一个 `vector<int>` 容器
- **`int num`**: 每次循环时，从 `nums` 中取出一个元素赋值给 `num`

**等价于传统for循环**

```cpp
// 范围for循环
for (int num : nums) {
    ++m[num];
}

// 等价的传统for循环
for (int i = 0; i < nums.size(); i++) {
    int num = nums[i];
    ++m[num];
}
```

#### 2.结构化绑定 (Structured Bindings)

```cpp
for (const auto &[key, value] : map) {
    // 循环体
}
```

- **`const auto &[k, v]`**:
  - `auto`: 自动类型推导
  - `const &`: 常量引用，避免复制，保证不修改原数据
  - `[k, v]`: 结构化绑定，自动解包键值对

**等价于传统写法**

```cpp
// 结构化绑定
for (const auto &[k, v] : m) {
    ans += v * (v - 1) / 2;
}

// 等价的传统写法
for (const auto &pair : m) {
    int k = pair.first;    // 键
    int v = pair.second;   // 值
    ans += v * (v - 1) / 2;
}

// 或者使用迭代器
for (auto it = m.begin(); it != m.end(); it++) {
    int k = it->first;     // 键
    int v = it->second;    // 值
    ans += v * (v - 1) / 2;
}
```

### 时空复杂度

### 排序算法

[算法复杂度一览表 - 算法导航](https://algo.codefather.cn/complexity)

[算法中七种常见的时间复杂度_多项式时间复杂度-CSDN博客](https://blog.csdn.net/u013832707/article/details/108647898)

[全面总结：常见数据结构时间复杂度比较表_数据结构时间复杂度汇总-CSDN博客](https://blog.csdn.net/weidl001/article/details/144222476)

## 1534.统计好三元组

### 绝对值函数 abs()

### 枚举优化

思路与算法

我们考虑 $O(n^2)$ 枚举满足 $|arr[i] - arr[k]| \leq b$ 的二元组 $(i, k)$，统计这个二元组下有多少 $j$ 满足条件。 
由题目已知 $j$ 的限制条件为 $|arr[i] - arr[j]| \leq a$ 且 $|arr[j] - arr[k]| \leq c$，我们可以拆开绝对值，得到符合条件的 $arr[j]$ 一定是  
$$
[arr[i] - a, arr[i] + a] \quad\text{和}\quad [arr[k] - c, arr[k] + c]
$$
两个区间的交集，我们记为 $[l, r]$。  

因此，在枚举 $(i, k)$ 这个二元组的时候，我们只需要快速统计出满足 $j < i$ 且 $arr[j]$ 的值域范围在 $[l, r]$ 的 $j$ 的个数即可。

很容易想到维护一个 $arr[j]$ 频次数组的前缀和 $sum$，对于一个二元组 $(i, k)$，我们可以 $O(1)$ 得到答案为  
$$
sum[r] - sum[l - 1]
$$

考虑怎么维护保证当前频次数组存的数的下标符合 $j < i$ 的限制，我们只要从小到大枚举 $i$，每次 $i$ 移动指针加一的时候，将 $arr[i]$ 的值更新到 $sum$ 数组中即可，这样能保证枚举到 $i$ 时 $sum$ 数组里存的值的下标满足限制。

> 「将 $arr[i]$ 的值更新到 $sum$ 数组中」这个操作在本方法中是暴力更新，因为数组的值域上限很小，有能力的读者可以考虑怎么进一步优化这一部分的复杂度，可以从离散化或者树状数组的角度考虑，这里不再赘述。

```c
class Solution {
public:
    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {
        int ans = 0, n = arr.size();
        vector<int> sum(1001, 0);
        for (int j = 0; j < n; ++j) {
            for (int k = j + 1; k < n; ++k) {
                if (abs(arr[j] - arr[k]) <= b) {
                    int lj = arr[j] - a, rj = arr[j] + a;
                    int lk = arr[k] - c, rk = arr[k] + c;
                    int l = max(0, max(lj, lk)), r = min(1000, min(rj, rk));
                    if (l <= r) {
                        if (l == 0) {
                            ans += sum[r];
                        }
                        else {
                            ans += sum[r] - sum[l - 1];
                        }
                    }
                }
            }
            for (int k = arr[j]; k <= 1000; ++k) {
                ++sum[k];
            }
        }
        return ans;
    }
};
```

复杂度分析

- 时间复杂度：$O(n^2 + nS)$，其中 $n$ 是数组 `arr` 的长度，$S$ 为数组的值域上限，这里为 $1000$。  
- 空间复杂度：$O(S)$。我们需要 $O(S)$ 的空间维护 `arr[i]` 频次数组的前缀和。

理解：

