# 1.两数之和

```c
// class Solution {
// public:
//     vector<int> twoSum(vector<int>& nums, int target) {
//         map<int,int> mp;
//         //mp.clear();
//         int ans;
//         for(int i=0;i<nums.size();i++){
//             mp.insert({nums[i],i});//大括号
//             if(mp.find(target-nums[i])!=mp.end()){//返回的是迭代器
//                 return {mp[target-nums[i]],mp[nums[i]]};//大括号
//             }
//         }
//         return{};//空
//     }
// };

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int,int> mp;
        //mp.clear();
        int ans;
        for(int i=0;i<nums.size();i++){
            if(mp.find(target-nums[i])!=mp.end()){//返回的是迭代器
                return {mp[target-nums[i]],i};//大括号
            }
            mp.insert({nums[i],i});//大括号
        }
        return{};//空
    }
};
```

## 分析：

一定要先查找后插入，
例如：nums = [3, 2, 4], target = 6
当i=0时，插入3，然后查找6-3=3，找到了，返回{0,0}，但这是错误的，因为同一个元素不能使用两次。

```c
mp.insert({nums[i],i});  // 先插入
if(mp.find(target-nums[i])!=mp.end()){  // 再查找
```

这会让你找到当前元素自己，而不是之前出现的元素。

## 题解：

```c
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};
```

#  584.寻找用户推荐人&1757.可回收且低脂的产品

简单回顾sql

# 709.转换成小写字母

## 方法一

```c
class Solution {
public:
    string toLowerCase(string s) {
        for (char& ch: s) {
            ch = tolower(ch);
        }
        return s;
    }
};
```

复杂度分析  

* 时间复杂度：O(n)，其中 n 是字符串 s 的长度。  
* 空间复杂度：O(1)，不考虑返回值的空间占用。  

### 分析：

1. **范围for循环**：这是一种**遍历容器**（如字符串、数组、向量等）中每个元素的简便方法。
   在这里，它遍历字符串`s`中的每一个字符。
2. `char& ch`：这里使用引用（reference）的方式声明循环变量`ch`。这意味着`ch`是字符串`s`中当前字符的别名（alias），
   对`ch`的修改会直接修改字符串`s`中的对应字符。
3. 如果不用引用，而是用`char ch`，那么`ch`只是字符串`s`中字符的一个副本，修改`ch`不会影响原字符串`s`。
4. 在这个函数中，我们的目的是将字符串`s`中的每个字符转换为小写，所以我们需要修改原字符串。因此，我们使用引用`char&`。
5. `tolower(ch)`：这个函数将大写字母转换为小写字母，对于非大写字母则保持不变。

### tolower()

## 方法二

可以想到的最简单的方法是使用一个哈希映射，哈希映射中包含 26 个键值对：(A,a)、(B,b)、…、(Z,z)。对于每个待转换的字符 ch，如果它出现在哈希映射中（即 ch 是哈希映射中的一个键），那么 ch 是大写字母，我们获取 ch 在哈希映射中的值即可得到对应的小写字母；如果它没有出现在哈希映射中，那么 ch 是其它字符，我们无需进行转换。  

然而这种方法需要一定量的辅助空间，不够简洁。一种更好的方法是观察小写字母和大写字母的 ASCII 码表示： 
·大写字母 A-Z 的 ASCII 码范围为 [65,90]； 
·小写字母 a-z 的 ASCII 码范围为 [97,122]。  

因此，如果我们发现 ch 的 ASCII 码在 [65,90] 的范围内，那么我们将它的 ASCII 码增加 32，即可得到对应的小写字母。

进而我们可以发现，由于 [65,90] 对应的二进制表示为 [(01000001)₂, (01011010)₂]，32 对应的二进制表示为 (00100000)₂，而对于 [(01000001)₂, (01011010)₂] 内的所有数，表示 32 的那个二进制位都是 0，因此可以对 ch 的 ASCII 码与 32 做按位或运算，替代与 32 的加法运算。

```c
class Solution {
public:
    string toLowerCase(string s) {
        for (char& ch: s) {
            if (ch >= 65 && ch <= 90) {
                ch |= 32;
            }
        }
        return s;
    }
};
```

复杂度分析  

* 时间复杂度：O(n)，其中 n 是字符串 s 的长度。  
* 空间复杂度：O(1)，不考虑返回值的空间占用。

![image-20251009151924278](C:\Users\HUAWEI\AppData\Roaming\Typora\typora-user-images\image-20251009151924278.png)

# 258.各位相加

```c
class Solution {
public:
    int addDigits(int num) {
        int sum=0;
        while(1){
            sum+=num%10;
            num=num/10;
            if(num==0){
                if(sum/10==0){
                    return sum;
                }
                num=sum;
                sum=0;
            }
        }
        
        return 0;
    }
};


//进阶
//用stack来解决x，还是要循环辅助
//看提示之后先试几个
/*
0            --------------------- 0
1            --------------------- 1
2            --------------------- 2
:
9            --------------------- 9
10            --------------------- 1
11            --------------------- 2
:
18            --------------------- 9
19            --------------------- 1
20            --------------------- 2
21            --------------------- 3
:
27            --------------------- 9
28            --------------------- 1
:
99            --------------------- 9

*/
//20->2
//48->3
//488->2
//58784->5
//873678->2
class Solution {
public:
    int addDigits(int num) {
        if(num==0) return 0;
        return num%9?num%9:9;
    }
};
```

